CLAUDE.md

# Simple Reversi

Rustで実装するシンプルなReversi（オセロ）ゲーム

## プロジェクト概要

CLI（コマンドライン）で動作するネットワーク対戦型のReversiゲーム

## ゲームルール
- 8x8のボード
- 黒と白の2人のプレイヤー
- 自分の石で相手の石を挟むと、挟まれた石がひっくり返る
- 両者が置けなくなったらゲーム終了
- 石の数が多い方が勝ち

## アーキテクチャ設計
- 相手との通信はTCPソケットを用いる
- クライアントが先手（黒）で、サーバー側が後手（白）固定となる
- 起動したらコンソールでクライアントかサーバーかを指定する
- クライアントの場合は、サーバーのアドレスとIPを指定する
- サーバーの場合は、アプリを開始して、相手（先手）からのコネクションを待つ
- 通信仕様は、8x8のマスを64個の配列として、左から右へ、さらにその後下の行へ同様に並ぶ形とする
- そのため、64個の要素の先頭は最上段一番左、末尾は最下段一番右、ということになる。
- 64個の配列は、int型(8バイト)の配列とする。x64アーキテクチャのPCで動作させること前提のため、リトルエンディアンで並べる。
- 配列のintの要素には、それぞれのマス目の石の内容が入り、石無しが0、黒い石が1、白い石が2、に割り当てられる。
- ゲームが始まると、まずクライアントからサーバーへコネクションする。
- 最初の配置は以下になる。クライアント、サーバーともに、以下の状態を持つ。(0が石無し、1が黒、2が白)
0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0
0 0 0 1 2 0 0 0
0 0 0 2 1 0 0 0
0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0
- ゲームが始まると、クライアント側は、該当の箇所に石を置こうとする。
- もしルール上おけない場所に置こうとしたら、そこにはおけない旨のワーニングを出す。
- おけるとこに置いたら、サーバー側に、上記の64個の配列（intなので512バイト）のデータを通知する
- サーバー側は上記データを受信したら、通知された内容をもとに、表示している配置内容を更新する。
- サーバー側で、石を受け付けられるようにする。以後は、上記と同様に、サーバーからクライアントへデータを送る。

### データ構造
```rust
// ボードの状態
enum Cell {
    Empty = 0,
    Black = 1,
    White = 2,
}

struct Board {
    cells: [[Cell; 8]; 8],
}

// プレイヤー
enum Player {
    Black,
    White,
}

// ゲーム状態
struct Game {
    board: Board,
    current_player: Player,
}
```

### 主要機能

1. **ボード表示**: 現在のボード状態をCLIに表示
2. **有効手判定**: 各位置に石を置けるかチェック
3. **石を置く**: 石を配置し、挟んだ石をひっくり返す
4. **ターン管理**: プレイヤーの交代、パス判定
5. **勝敗判定**: ゲーム終了条件と勝者の判定

### UI/UX方針

- CLIベースのシンプルなインターフェース
- ボードは文字で表現（例: `B`=黒, `W`=白, `.`=空）
- 座標入力は `a1` から `h8` の形式
- 有効な手を表示してユーザーをサポート

## 実装フェーズ

### Phase 1: 基本構造
- [ ] データ構造の定義
- [ ] ボード初期化
- [ ] ボード表示機能

### Phase 2: ゲームロジック
- [ ] 有効手判定アルゴリズム。ここはカスタマイズできるように関数化しておく。
- [ ] 石を置く処理
- [ ] ひっくり返す処理。ここはカスタマイズ可能なように関数化しておく。

### Phase 3: ゲームフロー
- [ ] ターン管理
- [ ] 入力処理
- [ ] 勝敗判定

### Phase 4: 改善
- [ ] コードのリファクタリング

## 技術スタック
- Rust 2024 edition
- 標準ライブラリのみ使用（依存関係なし）

## 開発方針
- 読みやすく保守しやすいコードを優先
