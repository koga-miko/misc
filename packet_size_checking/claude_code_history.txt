# claude操作履歴
ClaudeCodeへ依頼した内容と、応答内容を記載。
基本的にclaudeコマンドを打ち込んで以降のやり取りを丸ごとコピーしているが、
依頼内容の冒頭には、 <<★依頼内容>> を後から付与した。

<<★依頼内容>> Windows PC 内で、1つのサーバーを起動し、異なる２つの別プロセスのクライアントから、３秒～5秒周期で、1回あたり100～1000バイトのASCII文字列を、ランダムにサーバーへ送信し、サーバーからそれを丸ごと送り返すプログラムを作成してほしい。
※ネットワーク上に流れるデータのサイズをどの程度計測できるのか、実際に試すために、このようなプログラムを用意したいです。
ネットワークデータサイズ計測用のプログラムを作成します。Python で TCP サーバーとクライアントを実装しましょう。
Update Todos

サーバープログラムを作成

クライアントプログラムを作成

実行方法を記載したREADMEを作成
Write c:\Users\yoshi\OneDrive\work\tmp\packet_size_checking\server.py
⎿
119 lines
import socket
import threading
import time
from datetime import datetime

HOST = '127.0.0.1'
PORT = 12345

class ServerStats:
    def __init__(self):
        self.total_received = 0
        self.total_sent = 0
        self.message_count = 0
        self.lock = threading.Lock()

    def add_stats(self, received, sent):
        with self.lock:
            self.total_received += received
            self.total_sent += sent
            self.message_count += 1

    def get_stats(self):
        with self.lock:
            return self.total_received, self.total_sent, self.message_count

def handle_client(conn, addr, stats):
    """クライアント接続を処理"""
    print(f"[{datetime.now().strftime('%H:%M:%S')}] クライアント接続: {addr}")

    try:
        while True:
            # メッセージの長さを受信 (4バイト)
            length_data = conn.recv(4)
            if not length_data:
                break

            msg_length = int.from_bytes(length_data, 'big')

            # メッセージ本体を受信
            data = b''
            while len(data) < msg_length:
                chunk = conn.recv(min(msg_length - len(data), 4096))
                if not chunk:
                    break
                data += chunk

            if not data:
                break

            received_size = len(length_data) + len(data)

            # 受信したデータをそのまま送り返す（エコー）
            conn.sendall(length_data + data)
            sent_size = received_size

            # 統計情報を更新
            stats.add_stats(received_size, sent_size)

            print(f"[{datetime.now().strftime('%H:%M:%S')}] {addr} - 受信: {received_size}バイト, 送信: {sent_size}バイト")

    except Exception as e:
        print(f"[{datetime.now().strftime('%H:%M:%S')}] エラー ({addr}): {e}")
    finally:
        conn.close()
        print(f"[{datetime.now().strftime('%H:%M:%S')}] クライアント切断: {addr}")

def stats_monitor(stats):
    """定期的に統計情報を表示"""
    start_time = time.time()

    while True:
        time.sleep(10)
        received, sent, count = stats.get_stats()
        elapsed = time.time() - start_time

        print(f"\n=== 統計情報 (稼働時間: {elapsed:.1f}秒) ===")
        print(f"メッセージ数: {count}")
        print(f"総受信量: {received:,} バイト ({received/1024:.2f} KB)")
        print(f"総送信量: {sent:,} バイト ({sent/1024:.2f} KB)")
        print(f"平均レート: 受信 {received/elapsed:.1f} バイト/秒, 送信 {sent/elapsed:.1f} バイト/秒")
        print("=" * 50 + "\n")

def main():
    stats = ServerStats()

    # 統計情報モニタースレッドを起動
    monitor_thread = threading.Thread(target=stats_monitor, args=(stats,), daemon=True)
    monitor_thread.start()

    # サーバーソケットを作成
    with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as server_socket:
        server_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
        server_socket.bind((HOST, PORT))
        server_socket.listen(5)

        print(f"サーバー起動: {HOST}:{PORT}")
        print("クライアントからの接続を待機中...\n")

        try:
            while True:
                conn, addr = server_socket.accept()
                # 各クライアント接続を別スレッドで処理
                client_thread = threading.Thread(
                    target=handle_client,
                    args=(conn, addr, stats),
                    daemon=True
                )
                client_thread.start()
        except KeyboardInterrupt:
            print("\n\nサーバーを停止しています...")
            received, sent, count = stats.get_stats()
            print(f"\n最終統計:")
            print(f"  メッセージ数: {count}")
            print(f"  総受信量: {received:,} バイト")
            print(f"  総送信量: {sent:,} バイト")

if __name__ == "__main__":
    main()
Update Todos

サーバープログラムを作成

クライアントプログラムを作成

実行方法を記載したREADMEを作成
Write c:\Users\yoshi\OneDrive\work\tmp\packet_size_checking\client.py
⎿
124 lines
import socket
import random
import string
import time
import sys
from datetime import datetime

HOST = '127.0.0.1'
PORT = 12345

class ClientStats:
    def __init__(self):
        self.total_sent = 0
        self.total_received = 0
        self.message_count = 0

    def add_stats(self, sent, received):
        self.total_sent += sent
        self.total_received += received
        self.message_count += 1

    def print_stats(self, client_id):
        print(f"\n[クライアント{client_id}] 統計情報:")
        print(f"  メッセージ数: {self.message_count}")
        print(f"  総送信量: {self.total_sent:,} バイト ({self.total_sent/1024:.2f} KB)")
        print(f"  総受信量: {self.total_received:,} バイト ({self.total_received/1024:.2f} KB)")

def generate_random_ascii(min_size=100, max_size=1000):
    """ランダムなASCII文字列を生成"""
    size = random.randint(min_size, max_size)
    return ''.join(random.choices(string.ascii_letters + string.digits + string.punctuation + ' ', k=size))

def send_message(sock, message):
    """メッセージを送信（長さ情報付き）"""
    msg_bytes = message.encode('ascii')
    msg_length = len(msg_bytes)

    # メッセージの長さを4バイトで送信
    length_bytes = msg_length.to_bytes(4, 'big')

    # 長さ + メッセージを送信
    sock.sendall(length_bytes + msg_bytes)

    return len(length_bytes) + len(msg_bytes)

def receive_message(sock):
    """メッセージを受信（長さ情報付き）"""
    # メッセージの長さを受信
    length_data = sock.recv(4)
    if not length_data:
        return None, 0

    msg_length = int.from_bytes(length_data, 'big')

    # メッセージ本体を受信
    data = b''
    while len(data) < msg_length:
        chunk = sock.recv(min(msg_length - len(data), 4096))
        if not chunk:
            return None, 0
        data += chunk

    received_size = len(length_data) + len(data)
    return data.decode('ascii'), received_size

def run_client(client_id):
    """クライアントを実行"""
    stats = ClientStats()

    print(f"[クライアント{client_id}] サーバーに接続中: {HOST}:{PORT}")

    try:
        with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as sock:
            sock.connect((HOST, PORT))
            print(f"[クライアント{client_id}] 接続成功\n")

            while True:
                # ランダムなASCII文字列を生成
                message = generate_random_ascii(100, 1000)

                # サーバーに送信
                sent_size = send_message(sock, message)

                timestamp = datetime.now().strftime('%H:%M:%S.%f')[:-3]
                print(f"[{timestamp}] クライアント{client_id} - 送信: {sent_size}バイト (データ: {len(message)}バイト)")

                # サーバーからのエコーバックを受信
                received_message, received_size = receive_message(sock)

                if received_message is None:
                    print(f"[クライアント{client_id}] サーバーから切断されました")
                    break

                print(f"[{timestamp}] クライアント{client_id} - 受信: {received_size}バイト")

                # 送信データと受信データが一致するか確認
                if message == received_message:
                    print(f"[{timestamp}] クライアント{client_id} - ✓ データ検証成功")
                else:
                    print(f"[{timestamp}] クライアント{client_id} - ✗ データ検証失敗!")

                # 統計情報を更新
                stats.add_stats(sent_size, received_size)

                # 3～5秒のランダムな間隔で待機
                sleep_time = random.uniform(3.0, 5.0)
                print(f"[{timestamp}] クライアント{client_id} - 次の送信まで {sleep_time:.1f}秒待機\n")
                time.sleep(sleep_time)

    except KeyboardInterrupt:
        print(f"\n[クライアント{client_id}] 停止中...")
        stats.print_stats(client_id)
    except ConnectionRefusedError:
        print(f"[クライアント{client_id}] エラー: サーバーに接続できません。サーバーが起動しているか確認してください。")
    except Exception as e:
        print(f"[クライアント{client_id}] エラー: {e}")
        stats.print_stats(client_id)

if __name__ == "__main__":
    # コマンドライン引数からクライアントIDを取得（デフォルトは1）
    client_id = int(sys.argv[1]) if len(sys.argv) > 1 else 1

    run_client(client_id)
Update Todos

サーバープログラムを作成

クライアントプログラムを作成

実行方法を記載したREADMEを作成
Write c:\Users\yoshi\OneDrive\work\tmp\packet_size_checking\README.md
⎿
150 lines
# ネットワークパケットサイズ計測プログラム

ネットワーク上を流れるデータサイズを計測するための、シンプルなTCPエコーサーバー/クライアントプログラムです。

## 概要

- **サーバー**: 複数のクライアントからの接続を受け付け、受信したデータをそのまま送り返す（エコーバック）
- **クライアント**: 3～5秒周期で100～1000バイトのランダムなASCII文字列をサーバーに送信し、エコーバックを受信
- データサイズの統計情報をリアルタイムで表示

## ファイル構成

- `server.py` - サーバープログラム
- `client.py` - クライアントプログラム
- `README.md` - このファイル

## 実行方法

### 1. サーバーを起動

まず、ターミナル（コマンドプロンプトまたはPowerShell）を開いてサーバーを起動します。

```bash
python server.py
```

起動すると以下のように表示されます：
```
サーバー起動: 127.0.0.1:12345
クライアントからの接続を待機中...
```

### 2. クライアント1を起動

別のターミナルを開いて、1つ目のクライアントを起動します。

```bash
python client.py 1
```

### 3. クライアント2を起動

さらに別のターミナルを開いて、2つ目のクライアントを起動します。

```bash
python client.py 2
```

### 停止方法

各プログラムを停止するには、`Ctrl+C` を押してください。統計情報が表示されて終了します。

## 動作仕様

### サーバー（server.py）

- **待受アドレス**: 127.0.0.1:12345
- **機能**:
  - 複数クライアントの同時接続をサポート（スレッド処理）
  - 受信したデータをそのまま送り返す（エコーバック）
  - 10秒ごとに統計情報を表示
    - メッセージ数
    - 総受信量（バイト、KB）
    - 総送信量（バイト、KB）
    - 平均レート（バイト/秒）

### クライアント（client.py）

- **送信間隔**: 3～5秒（ランダム）
- **送信データサイズ**: 100～1000バイト（ランダム）
- **データ内容**: ランダムなASCII文字列（英数字、記号、スペース）
- **機能**:
  - サーバーにデータを送信
  - エコーバックされたデータを受信
  - 送受信データの一致を検証
  - 各送受信のサイズをリアルタイム表示
  - 終了時に統計情報を表示

### 通信プロトコル

各メッセージは以下の形式で送信されます：

```
[4バイト: メッセージ長（ビッグエンディアン）][可変長: メッセージ本体]
```

この形式により、可変長のメッセージを正確に送受信できます。

## 出力例

### サーバー側の表示

```
サーバー起動: 127.0.0.1:12345
クライアントからの接続を待機中...

[14:23:15] クライアント接続: ('127.0.0.1', 52341)
[14:23:15] ('127.0.0.1', 52341) - 受信: 558バイト, 送信: 558バイト
[14:23:16] クライアント接続: ('127.0.0.1', 52342)
[14:23:18] ('127.0.0.1', 52342) - 受信: 723バイト, 送信: 723バイト

=== 統計情報 (稼働時間: 10.0秒) ===
メッセージ数: 2
総受信量: 1,281 バイト (1.25 KB)
総送信量: 1,281 バイト (1.25 KB)
平均レート: 受信 128.1 バイト/秒, 送信 128.1 バイト/秒
==================================================
```

### クライアント側の表示

```
[クライアント1] サーバーに接続中: 127.0.0.1:12345
[クライアント1] 接続成功

[14:23:15.123] クライアント1 - 送信: 558バイト (データ: 554バイト)
[14:23:15.125] クライアント1 - 受信: 558バイト
[14:23:15.125] クライアント1 - ✓ データ検証成功
[14:23:15.125] クライアント1 - 次の送信まで 4.3秒待機
```

## 計測可能な情報

このプログラムでは以下の情報を計測できます：

1. **送信データサイズ**: アプリケーション層で送信したバイト数（4バイトの長さヘッダー + データ本体）
2. **受信データサイズ**: アプリケーション層で受信したバイト数
3. **メッセージ数**: 送受信したメッセージの総数
4. **総データ量**: 累積の送受信バイト数
5. **データレート**: 平均的な送受信速度（バイト/秒）

## 注意事項

- このプログラムはアプリケーション層でのデータサイズを計測します
- 実際のネットワーク上では、TCPヘッダー（20バイト）、IPヘッダー（20バイト）などのオーバーヘッドが追加されます
- より詳細なネットワーク層の計測には、Wireshark などのパケットキャプチャツールの使用を推奨します

## カスタマイズ

設定を変更したい場合は、各ファイルの先頭にある定数を編集してください：

- `HOST`, `PORT`: サーバーのアドレスとポート番号
- `generate_random_ascii(min_size, max_size)`: データサイズの範囲
- `random.uniform(3.0, 5.0)`: 送信間隔の範囲

## 必要な環境

- Python 3.6 以上
- 標準ライブラリのみ使用（追加のインストールは不要）
Update Todos

サーバープログラムを作成

クライアントプログラムを作成

実行方法を記載したREADMEを作成
ネットワークデータサイズ計測用のプログラムを作成しました！
作成したファイル
server.py - TCPエコーサーバー
client.py - TCPクライアント
README.md - 詳細な使用方法
実行方法
1. サーバーを起動（ターミナル1）
python server.py
2. クライアント1を起動（ターミナル2）
python client.py 1
3. クライアント2を起動（ターミナル3）
python client.py 2
主な機能
サーバー側
複数クライアントの同時接続に対応
受信データをそのままエコーバック
10秒ごとに統計情報を自動表示（総受信量、総送信量、メッセージ数、平均レート）
クライアント側
3～5秒周期でランダムに送信
100～1000バイトのランダムなASCII文字列を生成
送受信データの一致を検証
リアルタイムでサイズ情報を表示
計測できる情報
アプリケーション層での送受信バイト数
メッセージ数と総データ量
平均データレート（バイト/秒）
停止は Ctrl+C で行い、終了時に統計情報が表示されます。詳細は README.md をご覧ください。
.pcapngファイルを解析して、アドレスとポートのセットを一意として、それごとのサイズを羅列するPythonコードを出力して
.pcapngファイルを解析して、アドレスとポートのペアごとのデータサイズを集計するPythonプログラムを作成します。
Update Todos

pcapng解析プログラムを作成
Write c:\Users\yoshi\OneDrive\work\tmp\packet_size_checking\analyze_pcapng.py
⎿
170 lines
#!/usr/bin/env python3
"""
.pcapngファイルを解析して、アドレスとポートのペアごとのデータサイズを集計するプログラム

必要なライブラリ:
    pip install pyshark

使用方法:
    python analyze_pcapng.py <pcapngファイルパス>
"""

import sys
import pyshark
from collections import defaultdict
from datetime import datetime


def analyze_pcapng(pcapng_file):
    """
    pcapngファイルを解析して、接続ごとのデータサイズを集計

    Args:
        pcapng_file: .pcapngファイルのパス
    """
    print(f"pcapngファイルを読み込み中: {pcapng_file}\n")

    try:
        # pcapngファイルを開く
        cap = pyshark.FileCapture(pcapng_file)

        # 統計情報を保存する辞書
        # キー: (送信元IP, 送信元ポート, 宛先IP, 宛先ポート, プロトコル)
        # 値: {'packets': パケット数, 'bytes': 総バイト数, 'timestamps': [タイムスタンプリスト]}
        stats = defaultdict(lambda: {'packets': 0, 'bytes': 0, 'timestamps': []})

        total_packets = 0

        print("パケット解析中...")

        # 各パケットを解析
        for packet in cap:
            total_packets += 1

            try:
                # IPレイヤーがあるか確認
                if hasattr(packet, 'ip'):
                    src_ip = packet.ip.src
                    dst_ip = packet.ip.dst
                    protocol = None
                    src_port = None
                    dst_port = None

                    # TCPパケットの場合
                    if hasattr(packet, 'tcp'):
                        protocol = 'TCP'
                        src_port = packet.tcp.srcport
                        dst_port = packet.tcp.dstport
                        packet_size = int(packet.length)

                    # UDPパケットの場合
                    elif hasattr(packet, 'udp'):
                        protocol = 'UDP'
                        src_port = packet.udp.srcport
                        dst_port = packet.udp.dstport
                        packet_size = int(packet.length)

                    else:
                        # TCP/UDP以外のIPパケット
                        protocol = packet.ip.proto
                        src_port = '-'
                        dst_port = '-'
                        packet_size = int(packet.length)

                    # キーを作成（双方向の通信を別々に集計）
                    key = (src_ip, src_port, dst_ip, dst_port, protocol)

                    # 統計情報を更新
                    stats[key]['packets'] += 1
                    stats[key]['bytes'] += packet_size

                    # タイムスタンプを記録
                    if hasattr(packet, 'sniff_timestamp'):
                        stats[key]['timestamps'].append(float(packet.sniff_timestamp))

            except AttributeError as e:
                # パケットの属性にアクセスできない場合はスキップ
                continue

        cap.close()

        print(f"解析完了: {total_packets} パケット\n")

        # 結果を表示
        print("=" * 100)
        print(f"{'送信元アドレス':25} {'送信元ポート':12} {'宛先アドレス':25} {'宛先ポート':12} {'プロトコル':8} {'パケット数':10} {'総バイト数':15}")
        print("=" * 100)

        # バイト数でソート（降順）
        sorted_stats = sorted(stats.items(), key=lambda x: x[1]['bytes'], reverse=True)

        total_bytes = 0

        for key, value in sorted_stats:
            src_ip, src_port, dst_ip, dst_port, protocol = key
            packets = value['packets']
            bytes_count = value['bytes']
            total_bytes += bytes_count

            print(f"{src_ip:25} {str(src_port):12} {dst_ip:25} {str(dst_port):12} {protocol:8} {packets:10} {bytes_count:15,}")

        print("=" * 100)
        print(f"{'合計':82} {sum(s['packets'] for s in stats.values()):10} {total_bytes:15,}")
        print("=" * 100)

        # 接続ごとの詳細情報を表示（オプション）
        print_detailed_stats(sorted_stats)

    except FileNotFoundError:
        print(f"エラー: ファイルが見つかりません: {pcapng_file}")
        sys.exit(1)
    except Exception as e:
        print(f"エラー: {e}")
        sys.exit(1)


def print_detailed_stats(sorted_stats):
    """
    接続ごとの詳細統計情報を表示
    """
    print("\n\n" + "=" * 100)
    print("詳細統計情報")
    print("=" * 100)

    for idx, (key, value) in enumerate(sorted_stats[:10], 1):  # 上位10件のみ表示
        src_ip, src_port, dst_ip, dst_port, protocol = key
        packets = value['packets']
        bytes_count = value['bytes']
        timestamps = value['timestamps']

        print(f"\n[{idx}] {src_ip}:{src_port} → {dst_ip}:{dst_port} ({protocol})")
        print(f"    パケット数: {packets:,}")
        print(f"    総バイト数: {bytes_count:,} bytes ({bytes_count/1024:.2f} KB, {bytes_count/1024/1024:.2f} MB)")
        print(f"    平均パケットサイズ: {bytes_count/packets:.2f} bytes")

        if timestamps and len(timestamps) > 1:
            duration = max(timestamps) - min(timestamps)
            if duration > 0:
                print(f"    通信時間: {duration:.2f} 秒")
                print(f"    平均レート: {bytes_count/duration:.2f} bytes/sec ({bytes_count/duration/1024:.2f} KB/sec)")


def print_usage():
    """使用方法を表示"""
    print("使用方法:")
    print("  python analyze_pcapng.py <pcapngファイルパス>")
    print("\n例:")
    print("  python analyze_pcapng.py capture.pcapng")
    print("\n必要なライブラリ:")
    print("  pip install pyshark")


if __name__ == "__main__":
    if len(sys.argv) < 2:
        print("エラー: pcapngファイルを指定してください\n")
        print_usage()
        sys.exit(1)

    pcapng_file = sys.argv[1]
    analyze_pcapng(pcapng_file)
Write c:\Users\yoshi\OneDrive\work\tmp\packet_size_checking\requirements.txt
⎿
2 lines
pyshark
Update Todos

pcapng解析プログラムを作成
.pcapngファイル解析プログラムを作成しました！
作成したファイル
analyze_pcapng.py - pcapng解析プログラム
requirements.txt - 必要なライブラリ
セットアップ
まず、必要なライブラリをインストールします：
pip install pyshark
注意: pysharkはWiresharkのtsharkに依存しているため、事前にWiresharkをインストールしておく必要があります。
Wiresharkダウンロード: https://www.wireshark.org/download.html
使用方法
python analyze_pcapng.py <pcapngファイルパス>
例：
python analyze_pcapng.py capture.pcapng
出力内容
1. 接続一覧テーブル
各接続（送信元IP:ポート → 宛先IP:ポート）ごとに以下を表示：
送信元アドレス
送信元ポート
宛先アドレス
宛先ポート
プロトコル（TCP/UDP）
パケット数
総バイト数
総バイト数の多い順にソートされます。
2. 詳細統計情報（上位10件）
パケット数
総バイト数（bytes、KB、MB）
平均パケットサイズ
通信時間
平均データレート（bytes/sec、KB/sec）
出力例
==================================================================================================
送信元アドレス              送信元ポート    宛先アドレス              宛先ポート    プロトコル  パケット数      総バイト数
==================================================================================================
127.0.0.1                 52341        127.0.0.1                 12345        TCP              150          85,234
127.0.0.1                 12345        127.0.0.1                 52341        TCP              150          85,234
127.0.0.1                 52342        127.0.0.1                 12345        TCP              142          78,912
127.0.0.1                 12345        127.0.0.1                 52342        TCP              142          78,912
==================================================================================================
合計                                                                                      584         328,292
==================================================================================================

詳細統計情報
==================================================================================================

[1] 127.0.0.1:52341 → 127.0.0.1:12345 (TCP)
    パケット数: 150
    総バイト数: 85,234 bytes (83.24 KB, 0.08 MB)
    平均パケットサイズ: 568.23 bytes
    通信時間: 600.35 秒
    平均レート: 141.98 bytes/sec (0.14 KB/sec)
機能
✅ TCP/UDP通信の自動検出
✅ 双方向通信を別々に集計
✅ バイト数でソート表示
✅ 詳細な統計情報（レート、平均サイズなど）
✅ タイムスタンプ情報の記録
このプログラムを使えば、Wiresharkでキャプチャした.pcapngファイルから、どの接続でどれだけのデータが流れたかを簡単に確認できます！
<<★依頼内容>> 通信開始時間と通信終了時間も、タイムスタンプから具体的な日付・時刻・秒へ変換して、出力してほしい。
Read c:\Users\yoshi\OneDrive\work\tmp\packet_size_checking\analyze_pcapng.py
Update Todos

タイムスタンプを日付・時刻に変換して表示するように修正
Edit c:\Users\yoshi\OneDrive\work\tmp\packet_size_checking\analyze_pcapng.py
⎿
Added 15 lines
Update Todos

タイムスタンプを日付・時刻に変換して表示するように修正
修正完了しました！通信開始時刻と通信終了時刻が日付・時刻形式で表示されるようになりました。
変更内容
analyze_pcapng.py の print_detailed_stats 関数を修正し、以下の情報を追加しました：
通信開始時刻: タイムスタンプから変換した日付・時刻（ミリ秒まで）
通信終了時刻: タイムスタンプから変換した日付・時刻（ミリ秒まで）
出力例
詳細統計情報
==================================================================================================

[1] 127.0.0.1:52341 → 127.0.0.1:12345 (TCP)
    パケット数: 150
    総バイト数: 85,234 bytes (83.24 KB, 0.08 MB)
    平均パケットサイズ: 568.23 bytes
    通信開始時刻: 2025-10-26 14:23:15.123
    通信終了時刻: 2025-10-26 14:33:15.478
    通信時間: 600.35 秒
    平均レート: 141.98 bytes/sec (0.14 KB/sec)
フォーマット
日付形式: YYYY-MM-DD HH:MM:SS.mmm
年-月-日 時:分:秒.ミリ秒
パケットが1つだけの場合は「通信時刻」として単一の時刻を表示
これで、いつ通信が開始され、いつ終了したかが具体的に分かるようになりました！
<<★依頼内容>> １点質問。パケットサイズと通信回数は一致する？
良い質問です。パケットサイズと通信回数は一致しません。
違いの説明
パケット数（packets）
ネットワーク層での分割単位
1回の通信（send/recv）でも、データサイズが大きい場合は複数のパケットに分割されます
例：1500バイトのデータを送信 → MTU（Maximum Transmission Unit）により複数パケットに分割される可能性がある
通信回数（アプリケーション層での送受信回数）
アプリケーション層での send() / recv() の呼び出し回数
現在のプログラムでは計測していません
具体例
# クライアント側で1回の送信
send_message(sock, "A" * 5000)  # 5000バイトを1回送信

# ↓ ネットワーク層では...
# パケット1: 1500バイト
# パケット2: 1500バイト  
# パケット3: 1500バイト
# パケット4: 500バイト
# → 合計4パケット
この場合：
通信回数: 1回
パケット数: 4個
総バイト数: 5000バイト（+ ヘッダー）
現在のプログラムで分かること
analyze_pcapng.py で表示される 「パケット数」 は：
ネットワーク上を流れたパケットの個数
TCP/IPレベルでの分割後の数
サーバー/クライアントプログラムとの対応
server.py と client.py で表示される 「メッセージ数」 は：
アプリケーション層での通信回数（send/recvの回数）
これは .pcapng 解析では直接分からない
まとめ: パケット数 ≠ 通信回数です。1回の通信が複数パケットになることが普通です。
<<★依頼内容>> 質問です。総バイト数は、IPパケットの総バイト数ですよね？
はい、その通りです！
現在の実装での「総バイト数」
analyze_pcapng.py:58 を見ると：
packet_size = int(packet.length)
この packet.length は IPパケット全体のサイズ です。
含まれる内容
総バイト数には以下が含まれます：
IPヘッダー（通常20バイト）
TCPヘッダー（通常20バイト、オプションがあれば更に大きい）
アプリケーションデータ（実際のペイロード）
具体例
クライアントが "Hello"（5バイト）を送信した場合：
総バイト数 = IPヘッダー(20) + TCPヘッダー(20) + データ長ヘッダー(4) + "Hello"(5)
          = 約49バイト
レイヤー別の視点
レイヤー	サイズ
アプリケーション層	データ長(4) + "Hello"(5) = 9バイト
TCP層	TCPヘッダー(20) + データ(9) = 29バイト
IP層（packet.length）	IPヘッダー(20) + TCPセグメント(29) = 49バイト ← これが計測される
イーサネット層	さらにイーサネットヘッダーが追加（Wiresharkでは見えるがpysharkのpacket.lengthには含まれない）
注意点
packet.length は IPパケット全体のサイズ
純粋なアプリケーションデータのみのサイズではない
ネットワーク上の実際のトラフィック量に近い値です
もし アプリケーションデータのみ のサイズが知りたい場合は、TCPペイロード部分を別途取得する必要があります。
