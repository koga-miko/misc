# Simple Reversi - Network Game

Cで実装したシンプルなネットワーク対戦型のReversi（オセロ）ゲーム

## 概要

TCPソケット通信を使用して、2人のプレイヤーがネットワーク越しにReversiをプレイできます。

- クライアント：先手（黒石）
- サーバー：後手（白石）

## 必要な環境

- Windows 11 x64
- GCC（MinGW-w64など）
- Make

## ビルド方法

```bash
make
```

ビルドが成功すると `reversi.exe` が生成されます。

クリーンアップ：
```bash
make clean
```

## 実行方法

### 1. サーバー側（後手・白）

```bash
./reversi.exe
```

起動後、以下の操作を行います：
1. モード選択で `1` を入力（サーバーモード）
2. ポート番号を入力（デフォルト: 8888）
3. クライアントからの接続を待機

### 2. クライアント側（先手・黒）

```bash
./reversi.exe
```

起動後、以下の操作を行います：
1. モード選択で `2` を入力（クライアントモード）
2. サーバーのIPアドレスを入力（例: 192.168.1.100）
3. ポート番号を入力（デフォルト: 8888）
4. サーバーに接続

## ゲームの遊び方

### ボード表示

```
  a b c d e f g h
1 . . . . . . . .
2 . . . . . . . .
3 . . . . . . . .
4 . . . W B . . .
5 . . . B W . . .
6 . . . . . . . .
7 . . . . . . . .
8 . . . . . . . .
```

- `.` : 空きマス
- `B` : 黒石
- `W` : 白石

### 石の置き方

座標を入力して石を置きます（例: `d3`）

- 列：`a`～`h`
- 行：`1`～`8`

有効な手のみが受け付けられます。置けない場所に置こうとすると警告が表示されます。

### ゲームの流れ

1. クライアント（黒）が先手で開始
2. 交互に石を置いていく
3. 有効な手がない場合は自動的にパス
4. 両者とも置けなくなったらゲーム終了
5. 石の数が多い方が勝ち

## 通信仕様

### データフォーマット

- ボード状態：64要素のint64_t型配列（合計512バイト）
- エンディアン：リトルエンディアン
- 配列の順序：左から右、上から下

### セルの値

- `0`：空きマス
- `1`：黒石
- `2`：白石

### 配列のインデックス

```
0  1  2  3  4  5  6  7   (行1: a1～h1)
8  9  10 11 12 13 14 15  (行2: a2～h2)
...
56 57 58 59 60 61 62 63  (行8: a8～h8)
```

## ファイル構成

```
simple-reversi-for-MS-C/
├── main.c          # メインプログラム
├── reversi.c       # ゲームロジック実装
├── reversi.h       # ゲームロジックヘッダー
├── network.c       # ネットワーク機能実装
├── network.h       # ネットワーク機能ヘッダー
├── Makefile        # ビルド設定
├── .gitignore      # Git除外設定
├── README.md       # このファイル
└── CLAUDE.md       # 仕様書
```

## 主要機能

- ボード初期化と表示
- 有効手判定アルゴリズム
- 石を置く処理
- 石をひっくり返す処理
- ターン管理
- 勝敗判定
- TCPソケット通信（Windows Sockets）

## トラブルシューティング

### ビルドエラー

- GCCがインストールされているか確認
- MinGW-w64のbinディレクトリがPATHに含まれているか確認

### 接続エラー

- ファイアウォールでポートが開放されているか確認
- 正しいIPアドレスとポート番号を指定しているか確認
- サーバーが先に起動しているか確認

### その他

- Windows Defender等のセキュリティソフトがブロックしていないか確認

## ライセンス

このプロジェクトは自由に使用・改変できます。

## 開発方針

- 読みやすく保守しやすいコードを優先
- シンプルで明確な設計
- 適切なエラーハンドリング
