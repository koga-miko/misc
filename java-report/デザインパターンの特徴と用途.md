## GoF デザインパターン 23種 特徴・用途一覧

---

### 生成パターン（5種）

**1. Singleton**
インスタンスを1つだけに限定する。ログ管理、設定管理、DBコネクションプールなど「全体で共有すべき状態」に使う。

**2. Factory Method**
オブジェクト生成をサブクラスに委譲する。生成する型を呼び出し側が知らなくてよい設計にしたいときに使う。

**3. Abstract Factory**
関連するオブジェクト群をまとめて生成する。プラットフォームごとにUI部品一式を切り替えるような場面に使う。Factory Methodの上位概念。

**4. Builder**
複雑なオブジェクトを段階的に組み立てる。引数が多いコンストラクタを避けたいときに有効。RustのBuilderパターンはこれが定番。

**5. Prototype**
既存インスタンスをコピーして新しいオブジェクトを生成する。生成コストが高いオブジェクトをcloneで使い回す場面に使う。

---

### 構造パターン（7種）

**6. Adapter**
互換性のないインターフェースを橋渡しする。既存クラスを変更せずに新しいインターフェースに適合させたいときに使う。JNIやHIDLとJavaの橋渡しに近い概念。

**7. Bridge**
実装と抽象を分離して独立して変更できるようにする。例えばUIの形状と描画エンジンを別々に拡張したい場合に使う。

**8. Composite**
オブジェクトをツリー構造で扱い、単体と集合を同一視する。ファイルシステム（ファイルとフォルダを同じように操作）がわかりやすい例。

**9. Decorator**
既存オブジェクトに動的に機能を追加する。継承を使わず責務を重ねたいときに有効。JavaのI/Oストリームが典型例。

**10. Facade**
複雑なサブシステムをシンプルなインターフェースで隠蔽する。VHALの上位API層がこれに近い。使う側が内部を知らなくてよい設計にしたいときに使う。

**11. Flyweight**
多数の細かいオブジェクトを共有してメモリを節約する。ゲームの弾や文字フォントのように大量に生成される同一データに使う。組み込み・車載など**メモリ制約がある環境**で特に有効。

**12. Proxy**
本物のオブジェクトへのアクセスを代理オブジェクトで制御する。遅延初期化・アクセス制御・ログ記録などに使う。AndroidのBinderもProxy的な仕組み。

---

### 振る舞いパターン（11種）

**13. Chain of Responsibility**
複数のハンドラを連鎖させてリクエストを順番に処理する。どのハンドラが処理するかを動的に決めたいときに使う。Androidのタッチイベントのdispatchがこのパターン。

**14. Command**
操作をオブジェクトとしてカプセル化する。Undo/Redo・操作のキューイング・ログ記録が必要な場面に使う。

**15. Interpreter**
文法を定義してその言語を解釈・実行する。簡単なスクリプト言語や設定ファイルのパーサに使う。実用上は使用頻度が低め。

**16. Iterator**
コレクションの内部構造を隠しながら順番にアクセスする。JavaのIteratorインターフェース、RustのIntoIteratorがまさにこれ。

**17. Mediator**
複数オブジェクト間の通信を仲介者に集中させる。オブジェクト同士が直接参照し合うと複雑になる場合に使う。AACのViewModelがMediatorに近い役割を担う。

**18. Memento**
オブジェクトの内部状態を保存・復元する。Undo機能やゲームのセーブデータに使う。状態をカプセル化したまま外部に保存できる。

**19. Observer**
状態変化を複数のオブジェクトに通知する。AndroidのLiveData・EventListener・Broadcastがこのパターン。AAOS開発で最も頻繁に使う。

**20. State**
オブジェクトの内部状態によって振る舞いを変える。条件分岐の塊をStateクラスに分離できる。車載システムの動作モード管理（走行中・停車中・充電中など）に有効。

**21. Strategy**
アルゴリズムを差し替え可能にカプセル化する。処理方法を実行時に切り替えたいときに使う。音声認識エンジンの切り替えや圧縮アルゴリズムの選択など。

**22. Template Method**
処理の骨格を親クラスで定義し、詳細をサブクラスに委譲する。全体の流れは固定しつつ一部だけカスタマイズしたい場面に使う。AndroidのActivityライフサイクルがこれに近い。

**23. Visitor**
データ構造とその処理を分離する。新しい処理を追加しやすいが、データ構造の変更には弱い。コンパイラのASTトラバーサルなどに使う。

---

### まとめ

| カテゴリ | パターン数 | キーワード |
|---|---|---|
| 生成 | 5種 | 「どう作るか」 |
| 構造 | 7種 | 「どう組み合わせるか」 |
| 振る舞い | 11種 | 「どう連携するか」 |

AAOS開発で特に意識すると設計品質が上がるのは **Observer・State・Facade・Proxy・Command** あたりだと思います。